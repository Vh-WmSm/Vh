目录：
**Mouse

**Vim
*进入/退出编辑模式（append）
*复制粘贴
*基础命令
*撤销与重做
*保存与退出

**Linux基础命令
*cd —— 切换到某目录
*pwd —— 查看当前目录层级关系
*touch （文件名）—— 新建文件
*echo xxx —— 回显xxx（类似python的print()）
*vim（文件名）—— 新建文件并进入vim编辑器
*cat （文件名）（可添加多个文件） —— 把文件（小型文件）内容打印到界面（cmd是type 文件名）
*more、less —— 可翻页显示大文件
*ls —— 查看某目录下的文件
*mkdir —— 新建文件夹
*.、..、.（文件名）的意义
*cp —— 拷贝文件（有for循环详解）
*mv —— 移动文件
*rm —— 删除文件（cmd是del）
*rmdir、rm -r —— 两种删除目录的方法
*clear/Ctrl + l（小写L）—— 清屏（cmd是cls）
*history —— 查看在控制台执行过的所有命令历史记录

**Linux进阶命令
*重定向 > 或 >>
*管道（|）命令
*软链接与硬链接
*文件内容搜索命令：grep（内含正则表达式详解）
*查找文件命令：find —— 在指定目录下查找文件（包括目录）
*压缩(.zip、.gz、.bz2)和打包(tar) —— （其中.bz2的“2”读two）
*权限与权限管理
*获取管理员权限
*用户管理

**Git
*init、add、commit、status
*查看历史
*reset恢复
*在.config文件写入参数
*分支
*本地库与远程库
*如何启用ssh远程库push？
*如何清除github的历史记录？（两种方法）

**大陆上github网络问题的解决
*什么是hosts？

**常见异常与处理方法
*Exception —— the remote end hung up unexpectedly
*Exception —— error: failed to push some refs to 'https://github.com/Vh-WmSm/Vh.git'

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Mouse：
双击左键 —— 复制
单击中键 —— 粘贴

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Vim：
vim是一款功能强大的文本编辑器，也是早年Vi编辑器的加强版，它的最大特色就是使用命令进行编辑，完全脱离了鼠标的操作。vim是vi的升级版，可以有多级撤销、可视化等操作
*三种模式：
a.命令模式 —— 直接输入命令
b.编辑模式 —— 进入编辑模式编写文字
c.末行模式 —— 要加:的是末行模式命令

*进入/退出编辑模式（append）：
i —— 在光标前插入文本
a —— 在光标后插入文本
o —— 在当前行下一行插入文本
O —— 在当前行上一行插入文本
esc —— 退出编辑模式（退出编辑模式才能输入命令）

*复制粘贴（进入编辑模式后）
Ctrl + Insert 复制（同linux命令）（类比Windows的Ctrl + c）
Shift + Insert 粘贴（同linux命令）（类比Windows的Ctrl + v）

*光标移动、文本选择
h、j、k、l(或空格) —— 左、下、上、右
gg —— 光标到第一行开头
V —— 选择单行，然后↑或↓键可选择多行
G（Shift + g） —— 光标到末行开头
ggVG —— 文本全选
g_（或$(即shift + 4)） —— 光标到当前行末
^(即shift + 6)（或0） —— 回到当前的行首
数字 + G —— 跳转到指定行（若不知道那是第几行，可用:set nu显示行号）

*复制与粘贴（在命令模式时）
y —— 复制所选文本（然后可在电脑其他地方Ctrl + v粘贴）
p —— 在该行下方粘贴所复制内容
数字n + p —— 在该行下方粘贴n行所复制的内容
yy —— 复制单行
数字n + y —— 复制当前行且复制往下数n-1行

*删除
dd —— 删除单行（即把当前行剪切了，可换到别的行直接p粘贴）
数字n + dd —— 删除当前行且删除往下数n-1行
dG —— 删除当前光标行及往下行的内容
ggdG —— 第一行及其往下行都删除（即从上往下的全部删除）
dgg —— 删除当前光标行及往上行的内容
Gdgg —— 最后一行及其往上行都删除（即从下往上的全部删除）
x —— 删除光标后的一个字符
X —— 删除光标前的一个字符
数字n + x/X —— 原理同上

*撤销与重做
vi和vim的多级撤销不管操作了多少步，都可以撤销到刚进来的状态，但是一旦退出再进来，就无法撤销了
u —— 撤销（类比Ctrl + z）
Ctrl + r —— 重做（类比Ctrl + y 或 Ctrl + Shift + z）
Tips：这里vi和vim有点区别
如果是vi，那么u是改变撤销方向，即按一次u然后再ctrl + r、ctrl + r……就可以多级撤销，如果想重做，那么再按一次u，再ctrl + r、ctrl + r就可以多级重做。
而如果是vim则不停按u就是多级撤销，不停按ctrl + r就是多级重做。

*查找与替换
查找：
/（要查找的字符或字符串） —— 从当前光标往后查找指定内容
	n —— 查找下一个匹配的字符
	N —— 查找上一个匹配的字符
?（要查找的字符或字符串） —— 从当前光标往前查找指定内容
	n —— 查找上一个匹配的字符
	N —— 查找下一个匹配的字符
替换：
光标移动到要更改的字符前（这里说的字符前其实就是光标白点与该字符重合）按r然后按需要替换的目标字符 —— 单次替换
R(即shift + r) —— 切换到替换模式，esc退出

*保存与退出
:w —— 保存
:q —— 退出
ZZ（或“:wq”或“:x”） —— 保存并退出（若文件的user权限是只读的即只有r没有w，那么退出要用:wq!（或:x!），其中!表示强制执行保存，但如果是group或other权限没有w，此法也不能奏效）
:q! —— 不保存并退出（其中!指强制执行，即若写了东西但是确认不保存退出，若没写或没修改任何东西，直接:q即可退出）
注意：若文件修改后直接关闭终端，或意外关闭电脑，vim会作一个自动保存（假设文件为A.txt），生成一个.A.txt.swp的隐藏文件，当下次打开A.txt时会提示是否恢复（每次打开都会有），如果不想该信息产生，要手动删除当前目录下的隐藏文件rm .A.txt.swp

*常用命令扩展
J —— 把光标所在行和下一行提上来合并为一行
>> —— 向右缩进（类比Tab键）（一次缩进8个字符，也可调，在Linux的某配置文件更改一下即可）
<< —— 向左缩进（类比shift + Tab键）
:%s/要替换的内容/替换后的内容/g —— 全局替换（其中g代表“全局”的意思）
:开始行数,结束行数s/要替换的内容/替换后的内容 —— 局部替换
. —— 重复上一次命令操作
ctrl + f —— 下一屏
ctrl + b —— 上一屏
:set nu —— 显示行号
:set nonu —— 取消显示行号
:syntax on —— 开启语法高亮
（如对.py文件的print()高亮，但是vi不支持此命令）
（syntax - （计算机语言的）句法，句法规则，语构，语法）
:syntax off —— 关闭语法高亮

更多命令可以搜索百度：vim键盘图片，即可出现可视化的命令键盘图片

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Linux基础命令：
*cd —— 切换到某目录
cd（目录） —— 切换到指定目录（e.g:cd /bin（进入bin目录，这里有所有命令的文件合集））
cd .. —— 返回上一级（注意和cmd不同，这里d和.之间有一个空格，下同）
cd ~（或直接cd） —— 切换到当前用户的主目录（在windows里就是指c:\users\vh这个目录）
cd / — 切换到根目录（在windows里就是比c:\还上一级的目录）
cd - —— 切换到上一次目录
注意：
①cd bin、cd /bin和cd ../bin的区别：（bin是根目录/下的一个文件夹）
cd bin指当前就在根目录下，则可直接进入bin，若当前在别的位置，则会提示当前位置没有bin目录
cd /bin中的/指根目录，指进入根目录下的bin，无论现在在哪都能直接进入bin
cd ../bin中的/是一个分隔符，..指的是上一级目录，即指进入上一级的bin中，而若上一级没有bin则报错
②若cd到桌面，命令应是cd ~/Desktop，而不是desktop，不像cmd那样不区分大小写

*pwd —— 查看当前目录层级关系

*touch （文件名）—— 新建文件
（cmd是type nul > 文件名）

*echo xxx —— 回显xxx（类似python的print()）
echo $? —— 查看上一次命令或程序执行的状态码（0为正常结束）
echo $PATH —— 显示系统环境变量PATH
重定向用法：echo（写入内容） > （文件名）—— 新建文件并写入xx（可以为空）内容 （同cmd）
(echo 1;echo 2) > 1.txt —— 把1\n2输入到1.txt中，即写1，换一行写2
相当于：
(echo 1
>echo 2) > 1.txt —— 即;代替了回车

*vim（文件名）—— 新建文件并进入vim编辑器

*cat （文件名）（可添加多个文件） —— 把文件（小型文件）内容打印到界面（cmd是type 文件名）

*more、less —— 可翻页显示大文件
more（文件名）—— 针对文件内容很多的文件的查看（不会一次显示出来，分屏显示且有百分比，空格（f）显示下一屏信息，b显示上一屏，回车显示下一行q退出且内容显示停留在查到的位置）
less（文件名）—— 和more类似，但没有百分比显示，q退出后屏幕干干净净不会残留

*ls —— 查看某目录下的文件
ls -a —— 查看目录下所有文件（包含隐藏文件）
ls -l（或ll） —— 以长信息格式显示当前目录下的文件（会显示出文件权限、文件大小、链接数等信息）
（ls -l不能显示隐藏文件，但ls -la可以，与ll效果一致）
ls -lh(或ls -l -h 或ll -h) —— 与ls -l的区别是：-lh会把文件大小以xxK显示出来，而-l显示xx字节数
ls -al —— -a和-l的整合
ls （目录）—— 查看指定目录下的文件
ls -l （文件名）—— 查看指定文件的长信息

*mkdir —— 新建文件夹

*.、..、.（文件名）的意义
./ —— 表示当前目录
../ —— 表示上一级目录
.（文件名）—— 表示隐藏文件

*cp —— 拷贝文件（有for循环详解）
e.g： cp 1.txt ./2.txt（把当前目录下的1.txt复制到当前目录下并改名为2.txt）
e.g：用循环批量拷贝文件：
for i in {2..4};do
    cp 1.txt $i.txt
done
表示利用1.txt拷贝出2.txt、3.txt、4.txt三个文件

*mv —— 移动文件
（cmd是move）（move 1.txt 2.txt可以重命名文件）

*rm —— 删除文件（cmd是del）

*rmdir、rm -r —— 两种删除目录的方法
rmdir用来逐层删除空目录，如果某个目录中存在其他文件或目录，删除失败（此命令基本不用）
rm -r —— 删除目录（不考虑目录是否为空）
rm -f —— 强制删除不询问
（常用：rm -rf *（*表示通配符，表示所有文件）（若删除所有txt文件，rm -rf *.txt（或*txt也行，因为通配符可以代表txt前面的所有东西，也把.包含了））

*clear/Ctrl + l（小写L）—— 清屏（cmd是cls）
（命令） --help（或man （命令）） —— 查看帮助信息

*history —— 查看在控制台执行过的所有命令历史记录

*控制台的一些快捷键：
ctrl + - —— 窗口缩小
ctrl + shift + + —— 窗口放大

*一些其它的基础小操作：
cd /etc;cat passwd —— ;代替了回车，即执行完cd xx后立刻执行cat xx，这样写省了敲一次回车
（或者直接cat /etc/passwd，这样更省去了切到etc目录这一步）

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Linux进阶命令
*重定向 > 或 >>
将输出的屏幕的数据，重定向到一个指定位置（一般是指定一个文件），不管指定的文件是否存在，
都会创建新文件保存数据。（上面写的新建文件type nul > 1.txt 就是这个原理）
e.g: 
ls > 1.txt —— 把ls的内容输出到1.txt文件上（再次执行会覆盖，相当于python的open('w')）
ls >> 1.txt —— 在1.txt中追加ls的内容（相当于open('a')）
合并文件：
cat 1.txt 2.txt > 3.txt 把1.txt和2.txt内容合并到3.txt中

*管道（|）命令
一个命令的输出可以通过管道作为另一个命令的输入，可以理解成是一个容器，存放在终端显示的内容
e.g: 
ls -l | more 把ls -l显示的数据放到管道里，再用more作用于管道里的这些数据

*软链接与硬链接
类似于Windows下的快捷方式，当一个源文件的目录层级比较深，要想方便使用它可以给源文件一个链接
软连接：
a. 软链接无论更改源文件还是链接文件内容，都会更改文件内容
b. 软链接是链接文件链接到某个文件的绝对路径，而不管是不是这个文件，只要是这个名即可（如1.txt连接到2.txt，此时删了2.txt，再新建一个2.txt，这个1.txt一样能链接到新的2.txt）
c.软链接的原文件最好写绝对路径（不要写类似./xx/xx的相对路径，应把.换成.再往上的路径一直到根写下来才算绝对路径），防止链接失效
e.g :
ln -s （待链接（原）文件绝对路径）（链接文件文件名（不写绝对路径默认链接到当前目录））————同理，文件夹也可链接

硬链接 —— 指向同一块磁盘上数据的文件的引用
a. 硬链接只能链接文件，不允许对目录做硬链接
b. 硬链接不受路径影响
c. 硬链接会保持数据同步
d. 硬链接会改变文件属性信息中的链接数（文件属性信息即ls -l可以查看（文件权限和user中间的数字即为硬链接数））
e.目录的文件信息中的链接数表示当前目录下包含多少子目录

*文件内容搜索命令：grep（内含正则表达式详解）
grep '（要查找的内容）' （被查找的文件） —— 与查找内容完全一致
grep -i '' file —— 忽略大小写查找
grep -n '' file —— 显示匹配行号
grep -v '' file —— 显示不包含匹配文本的所有行
其中，指令前的-和要查找的内容两边的''可省略
-i、-n、-v可以混合使用，e.g : -in —— 忽略大小写且匹配行号查找

用正则表达式匹配查找：
^ —— 以指定字符串开头
$ —— 以指定字符串结尾
. —— 匹配任意一个字符（除换行符外）
e.g:
grep -in '^h' a.txt —— 把在a.txt以h开头的行忽略h大小写且匹配行号查找出来（^写在h前面）
grep -in 'h$' a.txt —— 以h结尾的查找出来（注意$写在h后面）
grep -in 'he.llo' a.txt —— 假如a.txt里有he1llo、he2llo、he3llo，那么都能打印出来
grep -in 'abc.' a.txt —— 若一行中包含abc.(.可以是任意字符)这个字符串，就把它打印出来
综合使用：设有a.txt内有6行字符串(12, a1, a1a1, a2, adsd, basd)
1.想查找一行只有两个字符且开头结尾为a.的
grep -in '^a.$' a.txt --- a1、a2
2.想查找一行只有两个字符的
grep -in '^..$' a.txt --- 12、a1、a2
所以，^$中间夹着多少个字符就规定了查找以多少个字符为一行的

进阶使用 —— grep 与 管道 结合
e.g1：查看某进程是否已开启
先了解一个命令：ps aux —— 查看当前Linux所有进程（若以后学习了mysql后，如果运行了mysql程序，ps aux会显示出mysql正在进程中，所以若要快速查看是否已经运行了mysql程序，则可用grep与管道结合来查找）
ps aux | grep mysql （'mysql'的''可以省略写，上面也说过）
其实这就相当于：
ps aux > b.txt
grep mysql b.txt
e.g2：查找某个在控制台敲过的命令历史
history | grep find —— 查找所有已执行过的find命令历史记录


*查找文件命令：find —— 在指定目录下查找文件（包括目录）
格式：
find 被查找的文件（这样默认当前目录，且查找结果不以./开头）
find 查找路径 -name 被查找的文件（查找结果以/开头）
Tips：在查找时，查找的范围包含“查找路径”及其下的子目录

通配符：* —— 可包含多个字符、? —— 只包含一个字符（使用通配符时最好加上''）
e.g:
find . -name '*基础*.txt' —— 查找当前目录及其子目录下的含“基础”的txt文件（可找到1.基础班.txt）
find . -name 'a?.txt' —— 查找a?的txt文件，可能是a1.txt、a2.txt……反正问号只代表一个字符
find . -name '?.txt' —— 查找以一个字符命名的所有txt文件
find / -name '*.txt' —— 从根目录下（全盘搜索）查找所有txt文件

其他用法：
find xxxxxxx -delete —— 查找到某些后，全部删除 e.g:find -name '?.txt' -delete
find . -size +4k —— 查找当前目录下大于4k的文件（换成-4k就是查找小于4k的文件）
find . -regex '^.$'.txt —— 运用正则表达式（正则在grep一节已详解）查找以一个字符命名的文件

*压缩(.zip、.gz、.bz2)和打包(tar) —— （其中.bz2的“2”读two）
压缩与解压缩：
zip:
zip （压缩包文件名） （要压缩的文件）—— 压缩成.zip格式文件
e.g: 
压缩：zip sql.zip *.sql
解压缩：unzip sql.zip
.gz:
e.g:
压缩：gzip 1.txt -> 1.txt.gz
解压缩：gzip -d 1.txt.gz -> 1.txt
.bz2:
压缩：bzip2 1.txt -> 1.txt.bz2
解压缩：bzip2 -d 1.txt.bz2 -> 1.txt

打包与解包：
格式：tar 参数 包名 被打包的文件
-c 创建.tar打包文件
-v 打印打包或解包的详细信息到控制台
-z 压缩或解压缩(.gz)
-j 压缩或解压缩(.bz2)
-x 解包
-f 指定文件名称，必须放到所有选项的后面，后面跟的是包名
-C 解包/解压缩到指定目录 —— 此参数解包/解压缩时用才奏效，压缩时不能用
e.g:
打包：tar cvf 1.tar 1.txt 2.txt -> 1.tar
（f参数必须放到所有参数后面）
（由于有v参数，故在控制台显示1.txt、2.txt这样的信息）
（打包不是压缩，文件大小大约是1.txt和2.txt的字节数之和）
（打包后，可以用以上学的gz、bz2压缩命令进行压缩得到1.tar.gz或1.tar.bz2）
解包：tar xvf 1.tar（-C 解包到指定目录） -> 1.txt 2.txt 
（其中-C不写默认解包到当前文件夹）
（若该文件夹下已有1.tar所打包的文件，如已有1.txt（与1.tar中的1.txt内容不一致），那么执行此命令会覆盖该1.txt，只会保留1.tar解包出来的1.txt）
tar zcvf 1.tar.gz
打包加压缩：tar czvf 1.tar.gz 1.txt 2.txt
（tar cjvf 1.tar.bz2 1.txt 2.txt）—— 用bzip2压缩
解包加解压缩：tar xzvf 1.tar.gz -C 指定解压缩目录
（tar xjvf 1.tar.bz2 -C 指定解压缩目录）—— 用bzip2解压
（其中-C不写默认解压到当前文件夹）

*权限与权限管理
字母法权限管理 —— rwx
按顺序为：-文件类型 （d代表文件夹）rwx文件所有者权限(u(user))r-x文件所有者所属组用户权限(g(group))r-x其他用户权限(o(other))
id 用户名 —— 查看当前用户所属用户编号、主组且主组编号、（主组, 次组1, 次组2)
r ——  read 读取权限（可读）
w —— write 写入权限（可写）
x —— exeute 执行权限（可执行）
- —— 占位符  无权限
a —— all 表示所有用户
chmod —— 修改权限
+ —— 增加权限
- —— 撤销权限
= —— 设置权限
用ls -l 可以查看文件权限
e.g：-rw-r--r-- 1 Vh 197121 16 Mar  3 22:40 1.txt
详解如下：
-rwxr-xr-x(文件权限(代表user拥有所有权限，group和other没有写入权限)) 1(硬链接数) Vh(user) 197121(组编号) 16(文件大小16字节) Mar 3 22:40(3月3日22:40) 1.txt(文件名)
修改权限：
e.g：
chmod g-x,o-x,u-w 1.txt —— 为group和other撤销执行权限，user撤销写入权限（注意，要连着写时，逗号后不能习惯性地加一个空格）
于是以上变成-r--r--r--，都只能读，不能写
但是user还是可以写入，因为有一个:wq!强制保存功能，但是group和other:wq!也不能保存了
chmod a+x 1.txt —— user、group、other都加上权限x
chmod a=--- 1.txt —— 所有权限撤销 —— ----------
chmod a=rx 1.txt —— 所有加上r和x权限 —— -r-xr-xr-x

数字法权限管理 —— rwx可以用数字代替
r —— 4 —— 2**2
w —— 2 —— 2**1
x —— 1 —— 2**0
- —— 0
rwx —— 7 —— 4+2+1
r-x —— 5 —— 4+1
e.g:
chmod 6 1.txt —— -------rw-
chmod 66 1.txt —— ----rw-rw-
chmod 666 1.txt —— -rw-rw-rw
chmod 777 1.txt —— -rwxrwxrwx
chmod 000 1.txt —— ----------
chmod 700 1.txt —— -rwx------

对文件夹的权限限制：
chmod 111 folder —— 只能执行cd folder，但不能读写
chmod 555 folder —— 可读可执行cd folder 后还可用ls读，但不能touch或rm之类的写操作

文件和目录的默认权限：
文件默认权限是755
目录默认权限：775
（可能不同的版本linux有差别）

*获取管理员权限
一般来说，程序员在操作Linux都是用一个权限比较低的用户去操作的，避免写错命令直接误删系统文件
如果使用这个低权限用户时，有些操作权限不够（提示Permission denied或xx权限不够），可临时借用管理员权限
e.g:
sudo find / -name *.sql
如果大量操作都需要管理员权限，懒得写sudo，则可切换到管理员root身份
sudo -s —— 切换后操作需谨慎！
退出管理员身份，切换回原身份
exit
已经在原身份，再次执行exit，会退出控制台

如果不知道现在自己是什么身份，可用whoami命令查看（一般这个在sh环境中运行才要用到，在bash中则会自动显示 —— vh@ubantu:）
whoami应用场景举例：
假如小明今天上班在机房维护电脑，下班了忘了退出登陆，第二天小明休息，换小亮维护电脑，那么小亮可以用whoami查询现在登陆的是哪个用户，若发现不是自己的用户，退出他的登自己的即可

*用户管理
先学基础：
①新建用户的主目录在/home默认(使用了-m选项)在下，其内容是原封不动拷贝/etc/skel目录的（skel即skeleton（框架、骨架））
这种机制的应用场景：
如果我是多用户系统管理员，那么可在skel目录下写一个ReadMe.txt的介绍，那么以后的新建用户都可看到我的自我介绍。或者在.bashrc文件中加入一些方便的环境变量或者命令别名,这样每个新建用户都可以使用这些功能。不过,更好的选择是把这些设置放到全局的 /etc/profile 中, skel 目录下的文件是拷贝过去的,如果你修改或者增加了新的文件,只有新建的用户才能使用，老用户是无法使用的。
②/etc/passwd文件中记录了所有用户信息，以
vh:x:1000:1000:Vh,,,:/home/vh:/bin/bash
jack:x:1001:1001::/home/jack:/bin/sh    为例
可见，每条信息都用:隔开。格式如下：
用户名:密码的占位符x:用户uid:所属组gid:备注(全名,房间号码,工作电话,家庭电话,其他):用户登录所使用的shell(用户的命令环境)(有bash和sh两种)
③/etc/shadow（要用sudo权限查看）文件中记录了所有用户的密码，密码用md5加密（md5是一种不可逆的加密方式，即使明文相同，但每次加密结果也不同）
④/etc/group文件中记录了所有组的名字与组编号（所属该组的用户不会在内）格式如下：
用户组名:用户组密码占位符（一般Linux系统的用户组都没有密码）：组id
⑤/etc/gshadow（要用sudo权限查看）文件中记录了各个组的一些基本信息介绍
以上的文件都可以用vi进行修改，运用命令只是一种帮我们快速把这些信息写进相应的文件的一个快捷方式

添加用户：
adduser —— 傻瓜式添加用户，以提示信息诱导添加用户密码、备注等，shell默认/bin/bash
useradd —— 以可选命令的方式添加用户
（假设useradd添加用户A，那么会自动编一个组命名为A，且用户A加入了A组（即在/etc/group文件写入一个组名为A的组，然后用户A加了进去，那么用户A的主组就是A组）） —— 主组次组会在用户组管理谈到
以下是useradd的常用选项介绍：（更多请查看useradd -h）
-M 强制不创建用户主文件夹（家目录）
（不写-m时默认也是不创建用户主文件夹）
（若创建的用户没有家目录，则会以HOME=/登录）
-m 在/home创建一个以该用户名命名的文件夹，其中内容拷贝的是/etc/skel的内容
-d 设置该用户主文件夹路径（格式：-m 用户名 -d /路径/主文件夹名）（与-m一起使用才有效）
-c 为用户加上备注（会将此备注文字加在/etc/passwd中的第5项字段中）
-s 指定用户登录所使用的shell —— 不写默认/bin/sh（sh的shell非常不方便，上下键似乎不能自动填充执行过的命令且其终端只有一个$，不能显示vh@ubantu:/etc这样的字样，所以最好设置为/bin/bash，或在/etc/passwd文件把该用户/bin/sh修改为/bin/bash也行）
-g 设定主组。指定用户所属的主要组，默认不指定会自动创建一个同名的组，且其所属主组就是这个同名的组
-G 设定次组。设置用户所属的次要组（可设置多个，格式：useradd -G cizu1,cizu2,cizu3）
-p 设置密码
（还未摸清这个参数的用法，这个直接设是一个明文密码且无效，所以不建议用这个设置密码，而是用以下说的方法）
-e 有效期限。指定帐号的有效期限。格式为YYYY-MM-DD，将存储在/etc/shadow
-f 缓冲天数。限定密码过期后多少天，将该用户帐号停用

查看用户信息：
id 用户名 —— 查看当前用户所属用户编号、主组且主组编号、（主组, 次组1, 次组2)
（系统用户编号一般在1000以内，自己创建的一般在1000以上）

设置密码：
设置他人用户密码：
创建用户后，用“sudo passwd （用户名）”的命令来设置或更改该用户的密码（若密码太短或太简单，会有报错提示，但不管他，正常输两次密码即可设置成功）
设置自己的密码：
passwd即可
设置root的密码：
sudo passwd

切换用户：
格式：su - 目标用户 
（若写-，切换后就到目标用户的家目录，若省略-，则切换后还是在切换前的目录）
（回车后会提示输入密码，输入的是目标用户的密码）
（这种切换是在当前用户临时进入目标用户，不是真正进入，所以切换后再exit会回到当前用户）
（若目标用户没有设置密码，则不能切换，会显示su:认证失败）
（在实验中发现，su - root提示su:认证失败，然后sudo passwd设置密码后发现可以切换，所以root应该是默认无密码的）
（su - root切换过去后pwd显示/root说明/root就是root的家目录，而用su root切换过去的效果与sudo -s的效果一致，只不过sudo -s不需要每次都输入密码（有一个缓存时间，可能输过一次后10分钟内就不需要再输，可直接切换过去）
（若切换了多次，则exit是一层层退出来。e.g:vh切到rose再切到jack，那么exit一次是回到rose，再exit才回到vh）

删除用户：
userdel -r 用户名（假设是jack）
（不加-r的话只删除用户，不删除主目录，则会导致/home中多了一个jack的垃圾文件夹）
（运行-r可能会有报错，说邮件池未找到或者其他的什么，没关系的，因为userdel只是帮我们走了一遍删除流程，所谓的删除流程就是上面“先学基础”中说的那几个文件，若在某文件中找不到关于这个用户的信息（可能手动删了，可能未生成），就会报错，但-r是肯定能把用户删除干净的）

*用户组管理
先学基础：
主组与次组：
每个用户都必须有一个主组，假如创建用户A没有用-g设定主组，那就会以自己的名字创建一个新组A，然后自己加入这个A组。假如已经存在了某些组，那么创建用户时使用-g参数可以指定这个用户的主组，使用-G参数可以指定这个用户的次组，次组可设定多个，格式上面已说
创建组：
sudo groupadd 组名
删除组：
sudo groupdel 组名
（注意删除组时不能有任何一个用户的主组是这个组，否则会报错，要删除相关的用户后才能删除这个组，但是若这个组只是某些用户的次组，则无所谓，可以直接删除）

*远程操作ssh和scp
通过ssh可以让客户端电脑远程操作Linux服务器
方法：
1.服务器端下载一个ssh服务端软件，sudo apt-get install penssh-server
（需在线安装，如果Linux虚拟机不能联网，可查看Else_Notes的“运行”笔记）
2.客户端如果是windows系统，则需安装OpenSSH for Windows这个软件（可以先查看C:\Windows\System32\OpenSSH是否存在，若存在则不用再下载），mac电脑默认已经下载。
3.然后Linux服务端（假设用户名为vh）打开终端输入ifconfig查看ip地址
（ip地址看的是inet6的，可能写成fe80::1cf4:cc55...的样子，也可复制下来使用，或它下一行那个inet 192.168.13.54也可以复制使用）
（如果Linux是虚拟机，则需把NAT模式改为桥接模式，因为NAT模式是虚拟的ip，桥接模式才是一台真正的电脑ip）
4.客户端打开终端输入ssh vh@ip地址，然后等待两秒再输入yes即可连接成功，就可以在客户端电脑操作Linux服务器了

通过scp可以在客户端和服务器端互传文件：
客户端传文件给服务器端：（上传）
scp a.txt vh@ip地址:/服务器的某路径
服务器端传文件给客户端：（下载）
sudo scp vh@ip地址:/a.txt .(这个点是下载到客户端的当前位置)
（要输入两次密码，第一次输入的是客户端的密码，第二次输入的是服务器端的密码）

FileZilla软件的使用：
FileZilla是一个免费开源的FTP软件，使用可视化方式进行上传和下载文件，以后可以通过FileZilla来代替scp命令
（是一个可视化的软件，粘贴ip和密码连接好了就可以直接拖动文件的方式进行上传和下载了）
（要注意的是，这个软件显示的服务器端的/不是真正服务器端的/，而是在/var/ftp/shared）

*软件安装和卸载
学习目标：能够使用apt-get命令安装软件

软件安装介绍：
Ubuntu软件安装有两种方式：
1.离线安装（deb文件格式安装）
dpkg -i 包名 —— 安装deb安装包（i指install）
dpkg -r 包名 —— 卸载deb安装包（r指remove）
2.在线安装（apt-get方式安装）—— 主要用于在线从互联网的软件仓库中搜索、安装、升级、卸载软件。

命令格式：
sudo apt-get（现在已经整合为直接apt也行了） install 安装包名（大概记得即可，有则会提示），表示在线安装deb安装包

更改镜像源：—— 镜像源就是下载软件来源的服务器
因为使用apt-get命令默认是从国外的服务器下载安装软件的，会导致下载安装速度很惶，所以需要更改成国内的镜像源服务器
镜像源更改方式：
1.图形界面操作更改：打开设置，打开软件和更新，选择主服务器为阿里或清华源，然后要输密码，然后输完了会弹出可用软件的列表信息已过时，按重新载入即可。
2.命令操作更改：打开清华软件镜像源mirrors.tuna.tsinghua.edu.cn网页，找到ubuntu然后点击它旁边的小问号，进入后选择想要的版本，然后复制下面框框中的所有文本，然后到终端把/etc/apt/sources.list文件内容全部更改为刚复制的（最好先备份一下sources.list），然后sudo apt update更新以下源（这个命令相当于上面图形界面处理的“重新载入”）。然后就可以使用sudo apt install 安装包名安装软件了

apt-get命令汇总：（以下apt-get均省略为apt）
sudo apt update —— 更新软件源
sudo apt upgrade —— 更新升级所有软件包
sudo apt upgrade 包名 —— 更新某个软件包
sudo apt list --upgradable —— 列出可更新的软件
sudo dist-upgrade —— 升级系统版本（Ubuntu的升级）
sudo apt install 包名 —— 安装一个软件包
sudo apt remove 包名 —— 删除一个软件包
sudo apt help —— 列举其他apt-get命令

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Git：
*init、add、commit、status
git init —— 初始化
git add .（在git 2.x版本-A和.一样，而在1.x版本.不会提交删除的文件）—— 提交当前目录及其所有子目录（因为是add .而.代表当前目录）所有未被追踪文件到暂存区
git add -u 提交修改的和删除的文件到暂存区，不提交新建的文件
git add 文件名——提交某文件到暂存区
git commit -m "版本信息" （若此时只想提交暂存区中某个文件，则此处写它的文件名）—— 提交文件到本地仓库
git commit -m用于提交暂存区的文件，git commit -am用于提交跟踪过的文件（可省去重新git add .这一步操作）
git status —— 查看本地库状态

*查看历史
git log —— 查看详细版本信息（log命令显示的版本信息与github历史记录同步）
git log --pretty=oneline —— log的简洁版（去掉了Author和Date）
git reflog —— 显示历史所有操作情况，版本号比log简略

*reset恢复
git reset --hard （版本号（简略、详细版本号都可）） —— 恢复到某个版本（并清除现版本所有新东西完全恢复回该版本）
git reset --soft （版本号） —— 恢复到某版本，工作区保留现状，目标版本不存在的东西全部存于暂存区中待commit
git reset --mixed （版本号） —— 恢复到某版本，工作区保留现状，目标版本不存在的东西不放入暂存区
git reset --hard/soft/mixed HEAD^(/~1) —— 恢复到上一个版本
git reset --hard/soft/mixed HEAD~n —— 恢复到上n个版本

*在.config文件写入参数
git config --global(--local) [xxx].xxx xxx —— 在全局（当前）仓库.gitconfig(.config)文件写入参数
e.g:
Command —— git config --global --user.name Vh-WmSm
等价于在全局.gitconfig文件里写入：（我的全局.gitconfig文件在---C:\Users\Vh）
[user]
	name = Vh-WmSm
git config --global --list(-l) —— 打印全局.gitconfig文件内容
git config --global(--local) --unset [xxx].xxx xxx —— （逆命令）清除.gitconfig中的xxx

*分支
git branch （分支名：hot-fix(热修)）—— 新建分支（把当前分支状态完全复制）  ------ a
git checkout （分支名）—— 切换分支  ------ b
git checkout -b （分支名）—— a、b命令同时进行
git checkout --orphan  new_branch —— 新建一个空白分支（Tips:  orphan --- 孤儿）
（“空白”——即会把原分支文件放在暂存区，但不会commit）
（若不做任何操作，再次切换回原分支，此空白分支不会保留）

git branch -v —— 查看所有分支
git branch -d （分支名）—— 普通删除分支
git branch -D （分支名）—— 强制删除分支（提示“error：分支未合并”时可用）
git merge （分支名）—— 合并分支（如当前在master分支想更改东西但不想妨碍master的运行，那么可新建分支“hot-fix”然后在新分支修改并commit后再回到master分支用merge命令可直接更新修改内容）
git branch -m 旧名字 新名字 —— 更改分支名

*本地库与远程库
本地库与远程库链接
git remote add vh https://github.com/Vh-WmSm/Vh.git 创建html远程库别名为vh
git remote -v —— 查看远程库别名
git remote rm （已存在的远程库别名）—— 删除远程库别名

本地库推送到远程库
git push vh （分支名）—— push分支“master”到远程库（vh是别名，可直接写网址）
git push vh （分支名）--force —— 强制push到远程库，否则会提交失败,报错原因：本地项目版本号低于远端仓库版本号

删除远程库某分支
git push vh :(分支名) —— 删除github上某分支

从远程库拉取内容到本地库
git pull vh （分支名）—— 从远程库拉取更新内容到本地库
git pull --rebase vh （分支名）—— 远程库同步到本地库

远程库克隆到本地库
git clone （https://xxx.git网址）—— 克隆远程库的项目到本地库
（不需要先git init，直接新建一个文件夹运行克隆命令即可）
（克隆不需要登陆账号，直接克隆即可）
（克隆自动拉取代码、初始化本地库、给被克隆链接其别名为origin）

*如何启用ssh远程库push？
Step1：git bash命令行中输入 ssh-keygen -t rsa -C "xxx@xx.com 创建ssh私/公匙
（其中的xxx是填邮箱，填github的注册邮箱即可）
（回车后会问你以下俩文件放哪，再回车默认路径即可）
（然后填写登陆密码，输入的密码有可能看不见，但你默打进去就行（再回车后会要你再打一次确认密码））
（创建后默认在x/.ssh目录中会生成id_rsa和id_rsa.pub两个文件）
（大概在global目录中，具体可以看生成时的文字提示）
Step2：进入GitHub网站，打开Settings
Step3：点击SSH and GPG keys后点击New SSH key
Step4：把id_isa.pub的内容粘贴到New SSH key的正文中，标题可随意写
Step5：命令行中输入 ssh -T git@github.com 测试SSH是否成功配置
（可能要输入一次yes或再填一次密码）
（若ssh -T git@github.com后长时间无反应，可考虑开手机关闭wifi开数据，然后开热点给电脑再次尝试）
Step6：git remote add vh-ssh git@github.com:Vh-WmSm/Vh.git —— 创建ssh远程库别名为vh-ssh
Step7：git push vh-ssh (分支名) —— （可能还要填密码）然后ssh push成功

*如何清除github的历史记录？（两种方法）
（假如有些东西想彻底删除，本地直接删除后push上去是不行的，因为还可以翻看历史记录找回）
法一：历史记录跳回某一个版本
原理：git的log与github的历史记录同步，所以git跳回某版本后再push到github即可
用git reset --soft （版本号）回到某版本后（再提一次：soft不会删除目标版本不存在的东西），
本地再更改到满意后（想删的删，想改的改），然后再push到远程库（会提醒版本过低，要用--force）

法二：想直接清空历史记录（此法原理：空分支的log是空的，且已知log与github的历史记录同步）
step 1：git checkout --orphan  （新分支名） —— 新建并转入空分支
step 2：git commit -m "xxx" —— 空分支中原文件已自动存入暂存区，commit即可
step 3：git branch -D （原分支名）—— 强制删除原分支
step 4：git branch -m （新分支名） （原分支名）—— 重命名新分支（防止github产生新分支）
step 4：git push vh （原分支名）--force —— 强制覆盖github上的原分支（历史记录也会被“空历史记录”覆盖）

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**大陆上github网络问题的解决
*什么是hosts？
a. What is hosts? hosts文件空白是不影响操作的，说到hosts文件就不得不谈到
它的作用，就是写出域名和ip的映射关系，在DNS没出来之前就是靠其工作的。
电脑想要去到哪个ip地址最先查看hosts文件，有的话就通过其对应关系解析进入
想要的域名。就像这个www.wesoullove.com,假如我给它写的对应关系是127.0.0.1
就无法进入这个域名，因为这个ip代表的就是本机地址。
b. 最新github的hosts下载地址：https://raw.hellogithub.com/hosts（hosts路径：C:\WINDOWS\system32\drivers\etc）
c. 所以如果出现网络问题，可以更新一下最新的hosts，也可以使用加速器：DevSidecar

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**常见异常与处理方法：
Command —— git push vh My_Project
*Exception —— the remote end hung up unexpectedly
Cause —— 网络问题或推送代码的大小超出了git默认的范围，可以调整git推送代码的最大值
Solution —— 执行以下命令，在.gitconfig添加参数
git config -- global http.lowspeedlimit=0
git config -- global http.lowspeedtime=999999
git config --global http.postBuffer 524288000 （设置缓存为500M）
Exception —— 添加参数后还是报一样的错
Cause —— 用http提交有上传大小限制
Solution —— 改为了ssh提交

Command —— git push vh （分支名）
*Exception —— error: failed to push some refs to 'https://github.com/Vh-WmSm/Vh.git'
Cause —— 远程库与本地库不一致（如单独在github上对某文件进行了更改，而不是在本地更改后再push到github上）
Solution —— git pull --rebase vh （分支名）
（先把远程库某行更新的内容同步到本地库某行（此操作不会覆盖本地已
更新待push的内容）然后再把本地待更新内容push到远程库即可）
e.g：
远程库初始：          本地库初始：
111                         111
远程库被更改：	本地库：
222                         111
远程库：		本地库被更改：
222			111
			333
执行：git pull --rebase vh （分支名）
远程库：		本地库被同步（原更改不变）：
222			222
			333
执行：git push vh （分支名）
远程库被更新：	本地库：
222			222
333			333
